var PodsUI = (function () {
  'use strict';

  var babelHelpers = {};
  babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };
  babelHelpers;

  /*global jQuery, _, Backbone, Mn */
  /**
   *
   */
  var FileUploadModel = Backbone.Model.extend({
  	defaults: {
  		'id': 0,
  		'icon': '',
  		'name': '',
  		'link': ''
  	}
  });

  /**
   *
   */
  var FileUploadCollection = Backbone.Collection.extend({
  	model: FileUploadModel,

  	field_meta: {},

  	initialize: function initialize(models, field_meta) {
  		this.field_meta = field_meta || {};
  		this.field_meta.field_options = this.field_meta.field_options || {};

  		// add() will always be called once per model in the collection
  		this.listenTo(this, 'add', this.onCollectionAdd);
  	},

  	onCollectionAdd: function onCollectionAdd(model, collection, options) {
  		this.truncateToFileLimit(this.field_meta.field_options.file_limit);
  	},

  	truncateToFileLimit: function truncateToFileLimit(limit) {
  		var first_model;

  		if (limit != 0 && this.length > limit) {

  			// We've gone over the item limit, so destroy the top (oldest) item, LIFO-style
  			// Note: calling destroy() directly on the model will send a REST DELETE request, this bypasses that behavior
  			first_model = this.at(0);
  			first_model.trigger('destroy', first_model);
  		}
  	}

  });

  var fileUploadItem = "<input\n\tname=\"<%- attr.name %>[<%- id %>][id]\"\n\tdata-name-clean=\"<%- attr.name_clean %>-id\"\n\tid=\"<%- attr.id %>-<%- id %>-id\"\n\tclass=\"<%- attr.class %>\"\n\ttype=\"hidden\"\n\tvalue=\"<%- id %>\" />\n<ul class=\"pods-file-meta media-item\">\n\t<% if ( 1 != options.file_limit ) { %>\n\t\t<li class=\"pods-file-col pods-file-handle\">Handle</li>\n\t<% } %>\n\t<li class=\"pods-file-col pods-file-icon\"><img class=\"pinkynail\" src=\"<%- icon %>\" alt=\"Icon\"></li>\n\t<li class=\"pods-file-col pods-file-name\">\n\t\t<% if ( 0 != options.file_edit_title ) { %>\n\t\t\t<input\n\t\t\t\tname=\"<%- attr.name %>[<%- id %>][title]\"\n\t\t\t\tdata-name-clean=\"<%- attr.name_clean %>-title\"\n\t\t\t\tid=\"pods-form-ui-<%- attr.name_clean %>-<%- id %>-title\"\n\t\t\t\tclass=\"pods-form-ui-field-type-text pods-form-ui-field-name-<%- attr.name_clean %>-title\"\n\t\t\t\ttype=\"text\"\n\t\t\t\tvalue=\"<%- name %>\"\n\t\t\t\ttabindex=\"2\"\n\t\t\t\tmaxlength=\"255\" />\n\t\t<% } else { %>\n\t\t\t<%- name %>\n\t\t<% } %>\n\t</li>\n\t<li class=\"pods-file-col pods-file-remove pods-file-delete\"><a href=\"#remove\">Remove</a></li>\n\t<% if ( 0 != options.file_linked ) { %>\n\t\t<li class=\"pods-file-col pods-file-download\"><a href=\"<%- link %>\" target=\"_blank\">Download</a></li>\n\t<% } %>\n</ul>\n";

  /**
   * Individual list items, representing a single file
   */
  var FileUploadItem = Mn.LayoutView.extend({
  	tagName: 'li',

  	className: 'pods-file',

  	ui: {
  		drag_handle: '.pods-file-handle',
  		download_link: '.pods-file-download',
  		remove_button: '.pods-file-remove'
  	},

  	template: _.template(fileUploadItem),

  	triggers: {
  		'click @ui.remove_button': 'remove:file:click'
  	},

  	/**
    * @todo: abstract this out.  All fields need access to the field meta and individual views shouldn't have to
    * worry about marshalling that data around.
    *
    * The return value here is what will be made available to the template
    */
  	serializeData: function serializeData() {
  		var data = this.model.toJSON();

  		data.attr = this.options['field_attributes'];
  		data.options = this.options['field_options'];

  		return data;
  	}

  });

  /**
   * The file list container
   */
  var FileUploadList = Mn.CollectionView.extend({
  	tagName: 'ul',

  	className: 'pods-files pods-files-list',

  	childView: FileUploadItem,

  	// @todo: abstract this out.  All fields need access to the field meta and individual views shouldn't have to
  	// worry about marshalling that data around.
  	initialize: function initialize(options) {
  		this.childViewOptions = options.field_meta;
  	},

  	onAttach: function onAttach() {

  		// @todo
  		// http://stackoverflow.com/questions/1735372/jquery-sortable-list-scroll-bar-jumps-up-when-sorting/4187833#4187833

  		// @todo: turn this into a list view behavior

  		if (1 != this.options['field_meta']['field_options']['file_limit']) {
  			// init sortable
  			this.$el.sortable({
  				containment: 'parent',
  				axis: 'y',
  				scrollSensitivity: 40,
  				tolerance: 'pointer',
  				opacity: 0.6
  			});
  		}
  	}

  });

  var fileUploadForm = "<a class=\"button pods-file-add pods-media-add\" href=\"#\" tabindex=\"2\"><%= options.file_add_button %></a>";

  var FileUploadForm = Mn.LayoutView.extend({

  	tagName: 'div',

  	ui: {
  		add_button: '.pods-file-add'
  	},

  	template: _.template(fileUploadForm),

  	triggers: {
  		'click @ui.add_button': 'add:file:click'
  	},

  	/**
    * @todo: abstract this out.  All fields need access to the field meta and individual views shouldn't have to
    * worry about marshalling that data around.
    *
    * The return value here is what will be made available to the template
    */
  	serializeData: function serializeData() {
  		var data = {};

  		data.attributes = this.options.field_meta['field_attributes'];
  		data.options = this.options.field_meta['field_options'];

  		return data;
  	}

  });

  /*global jQuery, _, Backbone, Mn */
  /**
   *
   * @param {Object} options
   *
   * @param {Object} options.browse_button   Existing and attached DOM node
   * @param {Object} options.ui_region       Marionette.Region object
   * @param {Object} options.field_options
   *
   * @param {string} options.field_options.file_modal_title
   * @param {string} options.field_options.file_modal_add_button
   * @param {string} options.field_options.file_limit
   * @param {string} options.field_options.limit_extensions
   * @param {string} options.field_options.limit_types
   * @param {string} options.field_options.file_attachment_tab
   *
   * @param {Object} options.field_options.plupload_init
   * @param {Object} options.field_options.plupload_init.browse_button
   *
   * @class
   */
  var PodsFileUploader = Mn.Object.extend({

    constructor: function constructor(options) {
      // Magically set the object properties we need, they'll just "be there" for the concrete instance
      this.browse_button = options.browse_button;
      this.ui_region = options.ui_region;
      this.field_options = options.field_options;

      Mn.Object.call(this, options);
    }

  });

  var fileUploadQueue = "<ul class=\"pods-file-meta media-item\">\n\t<% if ( '' === error_msg ) { %>\n\t\t<li class=\"pods-file-col pods-progress\"><div class=\"progress-bar\" style=\"width: <%- progress %>%;\"></div></li>\n\t<% } %>\n\t<li class=\"pods-file-col pods-file-name\"><%- filename %></li>\n</ul>\n<% if ( '' !== error_msg ) { %>\n\t<div class=\"error\"><%- error_msg %></div>\n<% } %>\n";

  var FileUploadQueueModel = Backbone.Model.extend({
  	defaults: {
  		id: 0,
  		filename: '',
  		progress: 0,
  		error_msg: ''
  	}
  });

  /**
   *
   */
  var FileUploadQueueItem = Mn.LayoutView.extend({
  	model: FileUploadQueueModel,

  	tagName: 'li',

  	template: _.template(fileUploadQueue),

  	attributes: function attributes() {
  		return {
  			class: 'pods-file',
  			id: this.model.get('id')
  		};
  	},

  	modelEvents: {
  		'change': 'onModelChanged'
  	},

  	onModelChanged: function onModelChanged() {
  		this.render();
  	}

  });

  /**
   *
   */
  var FileUploadQueue = Mn.CollectionView.extend({
  	tagName: 'ul',

  	className: 'pods-files pods-files-queue',

  	childView: FileUploadQueueItem
  });

var Queue = Object.freeze({
  	FileUploadQueueModel: FileUploadQueueModel,
  	FileUploadQueueItem: FileUploadQueueItem,
  	FileUploadQueue: FileUploadQueue
  });

  /*global jQuery, _, Backbone, Mn, wp, plupload */
  var $$4 = jQuery;

  var Plupload = PodsFileUploader.extend({
  	plupload: {},

  	initialize: function initialize() {

  		// Set the browse button argument for plupload... it's required
  		this.field_options.plupload_init.browse_button = this.browse_button;

  		this.plupload = new plupload.Uploader(this.field_options.plupload_init);
  		this.plupload.init();

  		// Setup all callbacks: ( event_name, callback, context )
  		this.plupload.bind('FilesAdded', this.onFilesAdded, this);
  		this.plupload.bind('UploadProgress', this.onUploadProgress, this);
  		this.plupload.bind('FileUploaded', this.onFileUploaded, this);
  	},

  	/**
    * Fired after files have been selected from the dialog
    *
    * @param up
    * @param files
    */
  	onFilesAdded: function onFilesAdded(up, files) {
  		var model, collection, view;

  		// Assemble the collection data for the file queue
  		collection = new Backbone.Collection();
  		$$4.each(files, function (index, file) {
  			model = new FileUploadQueueModel({
  				id: file.id,
  				filename: file.name
  			});

  			collection.add(model);
  		});

  		// Create a new view based on the collection
  		view = new FileUploadQueue({ collection: collection });
  		view.render(); // Generate the HTML, not attached to the DOM yet

  		// Reset the region in case any error messages are hanging around from a previous upload
  		// and show the new file upload queue
  		this.ui_region.reset();
  		this.ui_region.show(view);

  		// Stash references
  		this.queue_collection = collection;

  		up.refresh();
  		up.start();
  	},

  	/**
    *
    * @param up
    * @param file
    */
  	onUploadProgress: function onUploadProgress(up, file) {
  		var model = this.queue_collection.get(file.id);
  		model.set({ progress: file.percent });
  	},

  	/**
    *
    * @param up
    * @param file
    * @param resp
    */
  	onFileUploaded: function onFileUploaded(up, file, resp) {
  		var response = resp.response,
  		    new_file = [],
  		    model = this.queue_collection.get(file.id);

  		// Error condition 1
  		if ("Error: " == resp.response.substr(0, 7)) {
  			response = response.substr(7);
  			if (window.console) {
  				console.log(response);
  			}

  			model.set({
  				progress: 0,
  				error_msg: response
  			});
  		}
  		// Error condition 2
  		else if ("<e>" == resp.response.substr(0, 3)) {
  				response = $$4(response).text(); // Strip tags, text only
  				if (window.console) {
  					console.log(response);
  				}

  				model.set({
  					progress: 0,
  					error_msg: response
  				});
  			} else {
  				var json = response.match(/{.*}$/);

  				if (null !== json && 0 < json.length) {
  					json = $$4.parseJSON(json[0]);
  				} else {
  					json = {};
  				}

  				if ('object' != (typeof json === 'undefined' ? 'undefined' : babelHelpers.typeof(json)) || $$4.isEmptyObject(json)) {
  					if (window.console) {
  						console.log(response);
  					}
  					if (window.console) {
  						console.log(json);
  					}

  					model.set({
  						progress: 0,
  						error_msg: 'There was an issue with the file upload, please try again.'
  					});
  					return;
  				}

  				new_file = {
  					id: json.ID,
  					icon: json.thumbnail,
  					name: json.post_title,
  					link: json.link
  				};

  				// Remove the file from the upload queue model and trigger an event for the hosting container
  				model.trigger('destroy', model);
  				this.trigger('added:files', new_file);
  			}
  	},

  	// This should never be called as plupload intercepts the button click event itself
  	invoke: function invoke() {
  		return;
  	}

  });

  var MediaModal = PodsFileUploader.extend({
  	media_object: {},

  	invoke: function invoke() {

  		if (wp.Uploader.defaults.filters.mime_types === undefined) {
  			wp.Uploader.defaults.filters.mime_types = [{ title: 'Allowed Files', extensions: '*' }];
  		}

  		var default_ext = wp.Uploader.defaults.filters.mime_types[0].extensions;

  		wp.Uploader.defaults.filters.mime_types[0].extensions = this.field_options.limit_extensions;

  		// set our settings
  		this.media_object = wp.media({
  			title: this.field_options.file_modal_title,
  			multiple: 1 != this.field_options.file_limit,
  			library: {
  				type: this.field_options.limit_types
  			},
  			// Customize the submit button.
  			button: {
  				// Set the text of the button.
  				text: this.field_options.file_modal_add_button
  			}
  		});

  		// One-shot callback ( event, callback, context )
  		this.media_object.once('select', this.onMediaSelect, this);

  		// open the frame
  		this.media_object.open();
  		this.media_object.content.mode(this.field_options.file_attachment_tab);

  		// Reset the allowed file extensions
  		wp.Uploader.defaults.filters.mime_types[0].extensions = default_ext;
  	},

  	onMediaSelect: function onMediaSelect() {
  		var new_files = [];
  		var selection = this.media_object.state().get('selection');

  		if (!selection) {
  			return;
  		}

  		// loop through the selected files
  		selection.each(function (attachment) {
  			var attachment_thumbnail;
  			var sizes = attachment.attributes.sizes;

  			// by default use the generic icon
  			attachment_thumbnail = attachment.attributes.icon;

  			// only thumbnails have sizes which is what we're on the hunt for
  			if (sizes !== undefined) {
  				// Get thumbnail if it exists
  				if (sizes.thumbnail !== undefined && sizes.thumbnail.url !== undefined) {
  					attachment_thumbnail = sizes.thumbnail.url;
  				} // If thumbnail doesn't exist, get full because this is a small image
  				else if (sizes.full !== undefined && sizes.full.url !== undefined) {
  						attachment_thumbnail = sizes.full.url;
  					}
  			}

  			new_files.push({
  				id: attachment.attributes.id,
  				icon: attachment_thumbnail,
  				name: attachment.attributes.title,
  				link: attachment.attributes.url
  			});
  		});

  		// Fire an event with an array of models to be added
  		this.trigger('added:files', new_files);
  	}

  });

  var fileUploadLayout = "<div class=\"pods-ui-file-list\"></div>\n<div class=\"pods-ui-region\"></div>\n<div class=\"pods-ui-form\"></div>\n";

  // @todo: last vestiges of knowledge about any specific uploaders?
  var PLUPLOAD_UPLOADER = 'plupload';

  var FileUpload = Mn.LayoutView.extend({
  	template: _.template(fileUploadLayout),

  	regions: {
  		list: '.pods-ui-file-list',
  		ui_region: '.pods-ui-region', // "Utility" container for uploaders to use
  		form: '.pods-ui-form'
  	},

  	field_meta: {}, // @todo: things to be yanked when we abstract our field data needs

  	uploader: {},

  	initialize: function initialize() {
  		// @todo: abstract this out.  All fields need access to the field meta and individual views shouldn't have to
  		// worry about marshalling that data around.
  		this.field_meta = this.getOption('field_meta');

  		this.collection = new FileUploadCollection(this.getOption('model_data'), this.field_meta);
  		this.model = new FileUploadModel();
  	},

  	onRender: function onRender() {
  		// @todo: abstract this out.  All fields need access to the field meta and individual views shouldn't have to
  		// worry about marshalling that data around.
  		var listView = new FileUploadList({ collection: this.collection, field_meta: this.field_meta });
  		var formView = new FileUploadForm({ field_meta: this.field_meta });

  		this.showChildView('list', listView);
  		this.showChildView('form', formView);

  		// Setup the uploader and listen for a response event
  		this.uploader = this.createUploader();
  		this.listenTo(this.uploader, 'added:files', this.onAddedFiles);
  	},

  	/**
    * Fired by a remove:file:click trigger in any child view
    *
    * @param childView View that was the source of the event
    */
  	onChildviewRemoveFileClick: function onChildviewRemoveFileClick(childView) {
  		this.collection.remove(childView.model);
  	},

  	/**
    * Fired by a add:file:click trigger in any child view
    *
    * plupload fields should never generate this event as it places a shim over our button and handles the event
    * internally
    */
  	onChildviewAddFileClick: function onChildviewAddFileClick() {
  		// Invoke the uploader
  		this.uploader.invoke();
  	},

  	/**
    * Concrete uploader implementations simply need to: this.trigger( 'added:files', new_files )
    *
    * @param {Object[]} data An array of model objects to be added
    */
  	onAddedFiles: function onAddedFiles(data) {
  		this.collection.add(data);
  	},

  	createUploader: function createUploader() {
  		var options = this.field_meta['field_options'];
  		var Uploader;

  		// Determine which uploader object to use
  		// @todo: last vestiges of knowledge about any specific uploaders?
  		if (PLUPLOAD_UPLOADER == options['file_uploader']) {
  			Uploader = Plupload;
  		} else {
  			Uploader = MediaModal;
  		}

  		this.uploader = new Uploader({
  			// We provide regular DOM element for the button
  			browse_button: this.getRegion('form').getEl('.pods-file-add').get(),
  			ui_region: this.getRegion('ui_region'),
  			field_options: options
  		});
  		return this.uploader;
  	}

  });

  var pickLayout = "<div class=\"pods-pick-values pods-pick-checkbox\"></div>";

  /*global jQuery, _, Backbone, Mn */

  /**
   * Single item model representing a row of relationship data
   */
  var RelationshipModel = Backbone.Model.extend({
  	defaults: {
  		'id': 0,
  		'name': '',
  		'icon': '',
  		'selected': false
  	},

  	toggle_selected: function toggle_selected() {
  		this.set('selected', !this.get('selected'));
  	}
  });

  /**
   * Relationship item collection
   */
  var RelationshipCollection = Backbone.Collection.extend({
  	model: RelationshipModel,

  	// Return a new collection containing just the selected items in this one
  	filter_selected: function filter_selected() {

  		// Get an array with only the selected items
  		var filtered = this.filter(function (item_model) {
  			return item_model.get('selected');
  		});

  		// this.filter is going to return an array, so create a collection out of it
  		return new RelationshipCollection(filtered);
  	}
  });

  var checkboxItem = "<div class=\"pods-field pods-boolean\">\n\t<input\n\t\tname=\"<%- attr.name %>[<%- id %>]\"\n\t\t<%= selected ? 'checked=\"checked\"' : '' %>\n\t\tdata-name-clean=\"<%- attr.name_clean %>\"\n\t\tdata-label=\"<%- options.label %>\"\n\t\tid=\"<%- attr.id %>\"\n\t\tclass=\"pods-form-ui-field-type-pick\"\n\t\ttype=\"checkbox\" tabindex=\"2\" value=\"<%- id %>\">\n\t<label class=\"pods-form-ui-label\" for=\"<%- attr.name %>[<%- id %>]\">\n\t\t<%- name %>\n\t</label>\n</div>\n";

  /**
   * Represents the markup of a single row of relationship data
   */
  var CheckboxItem = Mn.LayoutView.extend({
  	tagName: 'li',

  	className: 'pods-pick',

  	ui: {},

  	template: _.template(checkboxItem),

  	triggers: {
  		'click @ui.checkbox': 'checkbox:click'
  	},

  	/**
    * @todo: abstract this out.  All fields need access to the field meta and individual views shouldn't have to
    * worry about marshalling that data around.
    *
    * The return value here is what will be made available to the template
    */
  	serializeData: function serializeData() {
  		var data = this.model.toJSON();

  		data.attr = this.options['field_attributes'];
  		data.options = this.options['field_options'];

  		return data;
  	}

  });

  /**
   *  Represents the markup of the container as a whole
   */
  var CheckboxList = Mn.CollectionView.extend({
  	tagName: 'ul',

  	childView: CheckboxItem,

  	initialize: function initialize(options) {
  		this.childViewOptions = options.field_meta;
  	}

  });

  var Pick = Mn.LayoutView.extend({
  	template: _.template(pickLayout),

  	regions: {
  		list: '.pods-pick-checkbox'
  	},

  	initialize: function initialize() {
  		// @todo: abstract this out.  All fields need access to the field meta and individual views shouldn't have to
  		// worry about marshalling that data around.
  		this.field_meta = this.getOption('field_meta');

  		this.collection = new RelationshipCollection(this.getOption('model_data'), this.field_meta);
  		this.model = new RelationshipModel();
  	},

  	onRender: function onRender() {
  		// @todo: abstract this out.  All fields need access to the field meta and individual views shouldn't have to
  		// worry about marshalling that data around.
  		var listView = new CheckboxList({ collection: this.collection, field_meta: this.field_meta });

  		this.showChildView('list', listView);
  	}

  });

  /*global jQuery, _, Backbone, Mn */
  var $ = jQuery;
  var app = {
  	fields: {}
  };
  app.Queue = Queue;

  /**
   * This is the workhorse that currently kicks everything off
   */
  jQuery(function ($) {
  	$('.pods-form-ui-field').pods_ui_field_init();
  });

  /**
   * Custom jQuery plugin to handle Pods Fields
   */
  jQuery.fn.pods_ui_field_init = function () {

  	return this.each(function () {
  		var data = {},
  		    field_id = undefined,
  		    field = undefined;

  		// Combine data from all in-line data scripts in the container
  		$(this).find('script.data').each(function () {
  			var this_data = $.parseJSON($(this).html());
  			$.extend(data, this_data);
  			$(this).remove();
  		});

  		if (data['field_type'] !== undefined) {

  			field = field_factory(data['field_type']);

  			if (field !== undefined) {
  				field_id = data.field_meta['field_attributes'].id;

  				app.fields[field_id] = new field({
  					el: this,
  					field_meta: data['field_meta'],
  					model_data: data['model_data']
  				});
  				app.fields[field_id].render();
  			}
  		}
  	});
  };

  /**
   * @param {string} field_type
   */
  var field_factory = function field_factory(field_type) {
  	var field_control = undefined;

  	switch (field_type) {
  		case 'file-upload':
  			field_control = FileUpload;
  			break;

  		case 'pick':
  			field_control = Pick;
  			break;

  		default:
  			//field_control = Hidden;
  			break;
  	}

  	return field_control;
  };

  return app;

}());